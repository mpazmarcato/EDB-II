\section{QuickSort}
Abaixo estão os pseudocódigos do algoritmo \textbf{QuickSort}, em versões iterativa e recursiva.Note que tanto a versão recursiva da \textbf{QuickSort} como a iterativa, esperam como entrada uma lista de números e através de seu algoritimo ordena essa lista, se necessário, assim retornando a lista, agora ordenada em ordem crescente. Há o uso da função auxiliar $particiona$, definida a seguir:
\begin{verbatim}
# Função para particionar um vetor em dois baseado em um pivô.
particiona(vetor, valorBaixo, valorAlto) { 
  # Obter o valor central relativo ao vetor.
  meio = valorBaixo + (valorAlto - valorBaixo) / 2
  pivo = vetor[meio] # Obtém o pivô.

  # Variáveis internas que controlam os índices em uso.
  inicio = valorBaixo
  final = valorAlto 
  
  # Percorre de uma extremidade à outra.
  enquanto(inicio <= final) { 
    # Ajusta o índice da extremidade esquerda até encontrar um elemento 
    # à esquerda maior que o pivô.
    enquanto (vetor[inicio] < pivo) { 
      inicio++
    }
    # Ajusta o índice da extremidade direita até encontrar um elemento 
    # à direita menor que o pivô.
    enquanto (vetor[final] > pivo) {
      final--
    }

    # Se os índices das extremidades não se encontraram, 
    # os valores maiores e menores que o pivô não estão
    # separados, fazendo necessária uma troca arbitrária.
    se (inicio <= final) {
      trocar(vetor, inicio, final)
      inicio++
      final--
    }
  }
  
  # Retorna a posição do novo pivô
  retorne inicio
}
   
# Função para trocar dois elementos em um vetor.
trocar(vetor, indice1, indice2) { 
  elementoAuxiliar = vetor[indice2]
  vetor[indice2] = vetor[indice1]
  vetor[indice1] = elementoAuxiliar
}
\end{verbatim}
\input{quicksort_sections/iteration.tex}
\input{quicksort_sections/iteration_analysis.tex}
\input{quicksort_sections/recursion.tex}
\input{quicksort_sections/recursion_analysis.tex}


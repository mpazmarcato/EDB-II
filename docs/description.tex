\section*{Descrição dos algoritmos}
Neste trabalho estão sendo analisados principalmente os algoritmos de ordenação Bubble Sort, Quick Sort e Merge Sort em suas versões iterativa e recursiva. Nesta introdução será explicado o funcionamento geral de cada algoritmo.
\subsection*{Bubble Sort}
O Bubble Sort, conhecido como "Ordenação por Bolha", é um algoritmo de ordenação simple e intuitivo. Seu funcionamento consiste em iterar repetidamente sobre uma lista $v$ comparando elementos vizinhos. Durante a iteração, se um elemento $x$ for maior que seu sucessor $y$, os dois trocam de posição, movendo $x$ uma posição à frente. Esse processo continua até que o maior elemento encontrado na lista seja movido para o final dela, garantindo a sua ordenação.

Na versão iterativa, uma variável booleana chamada \texttt{conflito} indica se houve troca de elementos durante uma passada pela lista. Inicialmente, \texttt{conflito} é definida como falsa; se alguma troca ocorrer, seu valor é atualizado para verdadeiro. Ao final da iteração, o algoritmo verifica \texttt{conflito} e, se for falso, o loop é interrompido, pois a lista já está ordenada. Caso contrário, a iteração é repetida até que \texttt{conflito} permaneça falso ao final de uma passada. Na versão recursiva, o algoritmo é executado chamando a si mesmo para ordenar sub-listas menores, ignorando o último elemento a cada chamada, pois ele já está na posição correta. A recursão continua até que a lista contenha apenas um elemento ou nenhum, configurando o caso base e garantindo que a lista está ordenada.

O algoritmo é custoso, pois foca em transportar o primeiro maior elemento da lista até o fim, depois o segundo maior e sucessivamente. O algoritmo é eficaz em realizar a ordenação, porém, não é eficiente devido à ordenação lenta, que requer múltiplas iterações dentro da lista até que ela esteja totalmente ordenada. 

\subsection*{Merge Sort}
O Merge Sort é um algoritmo de ordenação que segue a estratégia do \textit{dividir para conquistar}, consistindo em dividir uma lista maior em sub-listas cada vez menores até atingir um vetor que possa ser facilmente ordenado; com frequência, esse vetor tem tamanho 1 que, por definição, já está ordenado. Após a divisão completa a função \texttt{merge} é utilizada para combinar todas as sub-listas geradas de forma ordenada. 

Na versão iterativa do Merge Sort, o algoritmo não utiliza chamadas recursivas, mas realiza diversas junções sucessivas. Inicialmente, ele compara e une elementos individuais em pares, depois pares de duas sub-listas e sucessivamente até que toda a lista esteja unida em uma única sequência ordenada. Já na versão recursiva, o algoritmo chama a si mesmo para dividir a lista ao meio repetidamente, até que atinja a condição de um único elemento por sub-lista; após isso, ele passa a unir cada divisão com a função \texttt{merge}.

O algoritmo é eficaz em todos os casos e também eficiente, com a mesma complexidade tanto para os piores quanto melhores casos. Há, contudo, um custo extra de memória associado ao realizar cópias dos valores em vetores auxiliares na função \texttt{merge}.

\subsection*{Quick Sort}
O Quick Sort é um algoritmo de ordenação que utiliza a estratégia do \textit{dividir para conquistar}, do mesmo tipo do Merge Sort. mas com uma abordagem diferente na divisão dos elementos. O algoritmo opera a partir da seleção de um elemento denominado \textit{pivô}. A função \texttt{particiona} tem o papel de organizar a lista ao redor desse pivô, de modo que todos os elementos menores do que ele fiquem à esquerda e os maiores, à direita. Ela cumpre sua função buscando à esquerda um elemento maior que o pivô e à direita um menor que o pivô; quando encontrar ambos, realizar a troca de posições e continuar o processo no restante da lista. Desse modo, todos os elementos à esquerda do pivô serão menores e todos à direita serão maiores que ele.

Na versão iterativa, o processo é controlado por uma pilha que guarda os índices iniciais e finais da lista. Desse modo, a cada iteração o algoritmo passa como argumento para \texttt{particiona} uma sub-lista menor, e o conceito de dividir em torno de pivôs ainda se mantém sem a recursão. Já na versão recursiva, o Quick Sort chama a si próprio para ordenar cada sub-lista à esquerda e à direita do pivô por meio da \texttt{particiona}. Esse processo se repete até que o índice de final da sub-lista seja menor que o de início, ou seja, cada sub-lista tenha apenas um elemento.

O algoritmo é eficaz em todos os casos e eficiente em muitos, especialmente quando a escolha do pivô é feita de maneira adequada, como ao selecionar o elemento central ou um valor aleatório qualquer; isso minimiza o risco de divisões desbalanceadas. Contudo, caso a lista esteja ordenada ou o pivô escolhido for constantemente o menor ou maior elemento da lista, haverá uma série de rearranjos repetidos e as sub-listas serão divididas com uma maior quantidade de elementos. 
